---
created: 2024-08-26 14:05
updated: 2024-08-28 14:49
tags:
  - 백준
  - Baekjoon
  - BOJ
  - PS
  - 그래프/탐색
  - DFS
  - 깊이우선탐색
난이도: 골드2
---
> 문제 : https://www.acmicpc.net/problem/3109

# 풀이
1시간 30분 정도 풀었는데 답을 구하지 못해서 질문 탭을 확인했다.
`R*C` 격자의 첫 열에서 시작해 가장 끝 열까지 이동하는 파이프라인을 구축할 때, 파이프라인 끼리 겹치지 않고 만들 수 있는 최대 파이프라인 수를 구하는 문제다.
## 완전 탐색으로 생각해보기
일단 완전 탐색으로 문제를 푼다면 어떻게 풀 수 있을 지 생각해봤다.
지나갈 수 없는 위치인 건물에 대해서는 고려하지 않고 단순하게 먼저 생각해보았다.

첫 번째 행의 첫 번째 열에서 탐색을 시작한다고 가정하면, 현재 위치에서 우상단, 우측, 우하단 세 가지의 경로로 이동이 가능하다.
다음 위치에서도 똑같이 세 가지의 경로로 이동이 가능하며, 이는 다시 말해 O(3^N)의 시간 복잡도를 가진다는 것을 의미한다.

C가 최대 500이므로 최대 O(3^500)의 시간 복잡도를 가지게 되므로 1초의 시간 제한안에 답을 구하는 것이 불가능하다고 판단했다.
지나가지 못하는 길과 방문체크 등 시간 복잡도에 영향을 미치는 변수가 많기 때문에 애매한 부분이 있었지만, 단순히 생각했을 때는 다른 접근 방법이 필요하다고 봤다.

시간 초과가 발생하지만 알고리즘을 개선하는 방향으로 문제를 풀기 위해 완전 탐색 로직을 구체적으로 생각해봤다.

각 행의 첫 번째 열에서 출발해서 도달할 수 있는 위치를 탐색하면 각 행에서 연결할 수 있는 파이프라인을 찾을 수 있다.
각 행에서는 DFS를 사용해 끝 열로 이동할 수 있으며, 끝 열에 도달하면 다음 행으로 이동해 다시 탐색을 이어나갈 수 있다.
방문 체크를 통해 다음 행에서 중복된 경로를 사용하지 않도록 하면 각 행에서 가능한 모든 경로의 조합을 뽑아 최대 파이프라인의 수를 구할 수 있다.

당연하지만 이 코드의 시간 복잡도는 O(R * 3^C)이므로 절대 시간 제한을 통과할 수 없다.
## 메모이제이션은 가능할까?
시간 복잡도를 개선하기 위해서 메모이제이션을 활용할 방법이 없을 지를 고민해봤다.
`[i][j]`에 대해 도달 가능한 목적지의 수를 기록하면 어떨까 싶었는데 중복 경로를 사용하는 경우를 제외하지 못해서 불가능하다고 결론지었다.
## 그리디한 탐색
완전 탐색 로직을 생각하는 도중에 우상단, 우측, 우하단 순으로 이동하게 만들면 파이프라인을 최대한 위쪽으로 바짝 붙인 형태로 구성할 수 있다고 생각했다.
이 동작을 1행에서부터 각각 R행까지 수행하면 그리디하게 파이프라인이 탐색되고, 파이프라인의 최대 수를 구할 수 있지 않을까 싶었다.
다만 이렇게 탐색한 결과가 최적해라는 확신이 없었기에 더 시도해보지 않고 넘어갔다.

이후 정답을 구하지 못해서 문제 유형과 질문 탭을 확인해본 결과 그리디 문제가 맞았고, 이때 떠올린 방법이 정답이었다.
이 문제를 그리디하게 풀 수 있는 이유는 이동 방향이 항상 우측으로 이동하면서, 우상단, 우측, 우하단의 세 가지 경로로만 이동할 수 있기 때문이다.
탐색하는 경로의 순서를 우상단, 우측, 우하단 순으로 처리할 경우 현재 행에서 이동 가능한 경로 중 가장 상단의 칸들로만 이루어진 경로를 탐색한다.
이는 이후의 행들에서의 탐색에 최대한 영향을 미치지 않도록 하며, 최적해를 구할 수 있도록 한다.
#### 그리디한 동작이 최적해를 보장하는 이유는?
여기까지는 잘 이해가 됐지만 한 가지 걸리는 부분이 남아있다.
특정 행에서의 탐색을 생략하는 경우가 최적해가 되는 경우를 왜 고려하지 않는 지다.

이 부분에 대해서 고민을 해본 결과, 각 행에서의 탐색이 ==가능한 한== 높은 칸으로 구성된다는 점 때문이라는 것을 알 수 있었다. 
행의 탐색 순서 역시 높은 행인 0번 행에서, 낮은 행인 R-1행까지 탐색이 이루어진다. 이 때문에 어떤 행에서의 탐색을 생략한 경우에, 두 가지 경우를 생각해볼 수 있다.
현재 행을 x라고 했을 때, x-1행에서의 최적 경로를 z라고 해보자.
x 행에서의 최적 경로가 z와 겹치는 부분이 한 칸이라도 있다면, x행의 목적지는 x-1행의 목적지와 동일하다. 이는 경로를 구성하는 칸이 가능한한 높은 칸으로 구성되기 때문이다.
즉, 출발 행과 관계 없이 경로 중 한 칸이라도 공유한다면, 이 경로의 목적지는 항상 같음을 알 수 있다.

만약 x행의 최적 경로가 z와 겹치는 부분이 없다면, x-1행에서의 탐색을 생략하는 것이 오히려 최적해를 도출하지 못하게 한다.
다시 말해 두 경로가 겹치는 경우라면 어떤 행에서의 탐색을 생략하는 것이 최적해에 영향을 미치지 못하고, 겹치지 않는 경우라면 오히려 최적해를 도출하지 못하게 만든다.
따라서 어떤 행에서의 탐색을 생략하는 경우를 고려하지 않고 그리디하게 탐색하는 것이 최적해를 보장한다.
#### 시간 초과가 발생하지 않는 이유는 뭘까?
앞서 완전 탐색 로직에서 단순히 계산한 시간 복잡도가 `O(R*3^C)`이라고 했다.
이 시간 복잡도가 맞다면 그리디 알고리즘도 시간 초과가 발생해야 정상이다. 그렇다면 왜 시간 초과가 발생하지 않을까?
이는 방문 체크를 통해 각 칸을 한 번씩만 방문하는 것이 보장되기 때문이다.
앞서 완전 탐색에서 계산했던 시간 복잡도는 방문 체크를 고려하지 않고 항상 3개의 분기가 발생한다고 가정했을 때의 시간 복잡도다.
다만 실제 그리디 알고리즘에서는 이미 방문한 칸은 다시 방문하지 않기 때문에, 각 칸마다 최대 3개씩의 분기가 발생하는 것이 최악의 경우를 나타낸다.
즉, `O(3*R*C)`의 시간 복잡도를 가지게 된다.
# 코드
```java
static class P3109 {  
    static int R;  
    static int C;  
    static char[][] map;  
    static int[][] direc;  
    static boolean[][] visited;  
    static int result;  
    void solve() throws Exception {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
  
        StringTokenizer tk = new StringTokenizer(br.readLine());  
        R = Integer.parseInt(tk.nextToken());  
        C = Integer.parseInt(tk.nextToken());  
  
        map = new char[R][C];  
        for (int i = 0; i < R; i++) {  
            String line = br.readLine();  
            for (int j = 0; j < C; j++) {  
                map[i][j] = line.charAt(j);  
            }  
        }  
  
        direc = new int[][]{  
            new int[]{-1, 0, 1},  
            new int[]{1, 1, 1},  
        };  
  
        visited = new boolean[R][C];  
  
        for (int i = 0; i < R; i++) {  
            result += dfs(i, 0);  
        }  
  
        System.out.println(result);  
    }  
  
    int dfs(int r, int c) {  
        if (c == C-1) {  
            return 1;  
        }  
  
        for (int i = 0; i < 3; i++) {  
            int nextR = r + direc[0][i];  
            int nextC = c + direc[1][i];  
            if (isValidPos(nextR, nextC)) {  
                visited[nextR][nextC] = true;  
                int result = dfs(nextR, nextC);  
                if (result == 1) return result;  
            }  
        }  
        return 0;  
    }  
  
    boolean isValidPos(int r, int c) {  
        return r >= 0 && r < R && c >= 0 && c < C && !visited[r][c] && map[r][c] == '.';  
    }  
}
```