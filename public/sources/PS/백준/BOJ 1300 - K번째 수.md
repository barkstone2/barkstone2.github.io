---
created: 2024-09-29 13:30
updated: 2024-09-30 19:20
tags:
  - 백준
  - Baekjoon
  - BOJ
  - PS
난이도: 골드1
---
> 문제 : https://www.acmicpc.net/problem/1300

# 풀이
시간 안에 푸는데 실패한 문제다.
나중에 문제 유형을 확인해보니 이분 탐색이었고, 전혀 생각도 못한 유형이었기에 시간을 더 투자했어도 풀지 못 했을 것 같다.

문제를 풀고 한 달 정도 시간이 지난 뒤에 복기겸 다시 풀어봤는데 여전히 푸는데 실패했다.
이분 탐색 문제라는 것을 알고 풀었는데도 어떻게 이분 탐색을 적용해야 할지가 떠오르지 않았다.

어떻게 이분 탐색인 것을 판단할 수 있을 지 고민하며 문제를 분석해봤다.

먼저 이 문제에 이분 탐색 도입이 필요한 지, 필요성을 판단해 봐야 한다.
이분 탐색 도입으로 시간 복잡도 개선이 가능할 지, 정렬된 데이터가 존재하는 지를 먼저 판단해야 한다.

먼저 N의 값이 최대 `10^5`이기 때문에 `O(N^2)`의 시간 복잡도로는 시간 초과가 발생한다.
`O(NlogN)`으로 줄인다면 시간 초과가 발생하지 않으므로 이분 탐색 도입 필요성은 충분하다.

B가 오름차순 정렬되어 있다는 정보도 주어지므로 정렬된 데이터도 존재한다.

마지막으로 확인해봐야 할 것은 어떻게 탐색 범위를 반으로 줄여나갈 수 있느냐다.
개인적으로 이 부분이 가장 어려운 부분이라고 생각한다.

문제에서 정렬된 데이터는 B지만, B를 구성하는 데이터들이 실제로 어떻게 이루어져 있는지는 판단하기가 어렵다.
이는 B를 실제로 초기화하는 것이 어렵기 때문이며, B에서 탐색해야 할 값도 문제에서 드러나있지 않다.

우리가 알 수 있는 건 B의 값들이 `A[i][j]`를 기준으로 초기화되었고, 인덱스인 k 값이 제공된다는 정보 뿐이다.
알 수 없는 값으로 문제를 해결할 수는 없으니 탐색 범위를 반으로 줄일 수 있다면 이 두 가지 값을 활용해야 한다는 것이 명확하다.

k 값을 어떻게든 활용해야 하니 정렬된 자료 구조에서 인덱스가 가지는 의미를 생각해보자. 오름차순 데이터에서 k번째 값은 자신보다 작거나 같은 값이 k개 존재한다는 것과 동일하다.
`B[k+1]`은 자신보다 작거나 같은 값이 k+1개가 있다는 의미이기도 하다.

현재시점에 실제로 `B[k]`가 어떤 값인 지는 알 수 없다. `B[k+1]` 역시 마찬가지다.
하지만 각각의 수보다 작거나 같은 수의 개수가 k개, k+1개라는 것은 명확하다.

또한 B를 구성하는 값중 첫 번째 값과 마지막 값은 문제에서 주어지는 정보를 통해 손쉽게 알 수 있다. 첫 값은 1이고, 마지막 값은 NxN이 된다.
그렇다면 B에 포함될 수 있는 값의 범위가 1~NxN이라고도 생각할 수 있다.

문제에서 우리에게 요구하는 것은 `B[k]`이고, 우리는 이 값이 자신보다 작거나 같은 수가 k개인 수라는 정보를 알고 있다.
그렇다면 1~NxN의 수 중 자신보다 작거나 같은 수가 k개인 수를 찾을 수 있다.

다음으로 A 배열에 대해 생각해보자. A 배열의 모든 값은 행 번호 x 열 번호를 값으로 가진다.
행을 기준으로 생각해보면 동일한 행은 현재 행 번호의 배수로만 이루어져 있다는 것을 알 수 있다.
예를 들어 `A[2] = {2*1, 2*2, 2*3, 2*4, …, 2*N}`이 된다.

`B[k]`를 x로 둔다면 우리는 `A[2]`에서 x보다 작거나 같은 수의 개수를 구해야 한다.
`A[2]`는 모두 2의 배수이므로 2로 나누면 1, 2, 3, ..., N이 된다.
x 역시 2로 나눌 수 있다. 2로 나눈 값이 5.7이라고 가정해보자. 소수점을 버림하면 5가 될 것이고, 이는 `A[2]`에서 5보다 작거나 같은 수가 5개라는 의미가 된다.

이는 다른 모든 행에 대해서도 동일하게 적용할 수 있다.
즉, 어떤 수 x를 모든 행 번호로 나누고 더하면 x보다 작거나 같은 수의 개수를 구할 수 있다.

이제 탐색 범위를 반으로 줄일 방법이 나왔다.
1 ~ NxN 값 범위에 대해 mid 값을 설정하고, 해당 값보다 작거나 같은 수의 개수를 모든 행번호로 나누고 더한 값을 기준으로 구한다.
이후 k와 이 값을 비교해 탐색 범위를 줄일 수 있다.
## 추가로 고려해야 할 점
mid를 행 번호로 나눈 값이 해당 행에서 mid보다 작은 수의 개수를 나타내지만 이 값이 N보다 커지는 경우가 발생할 수도 있다.
때문에 `min(N, mid/i)`를 취해 실제보다 많은 개수가 더해지지 않도록 처리해야 한다.

또한 k가 항상 `min(10^9, N^2)`이고 `B[k] <= k`가 보장되기 때문에 탐색의 끝 범위를 k로 설정할 수 있다.

이분 탐색 시 mid를 반환하는 대신 left 범위에 대한 추가 탐색을 이어나가야 한다.
count 값이 k와 일치하는 값 중 가장 작은 값을 반환해야 올바른 정답이 된다. 이는 mid 값이 실제로 배열 내에 포함된 값이 아닐 수 있기 때문이다.

예를 들어 배열 B가 `[1, 2, 2, 3, 3, 4, 6, 6, 9]`일 때, 7보다 작거나 같은 수와 6보다 작거나 같은 수의 개수는 동일하다.
이는 7이 B 배열 내에 포함되어 있지 않기 때문이며, 7이 배열에 포함되어 있다면 6과 7보다 작거나 같은 수가 같아질 수가 없다.
# 코드
```java
static class P1300 {
    static int N;
    void solve() throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        N = Integer.parseInt(br.readLine());
        int K = Integer.parseInt(br.readLine());

        int left = 1;
        int right = K;
        while (left <= right) {
            int mid = (left + right) / 2;
            int count = countLte(mid);
            if (count < K) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        System.out.println(left);
    }

    int countLte(int mid) {
        int result = 0;
        for (int i = 1; i <= N; i++) {
            result += Math.min(N, mid/i);
        }
        return result;
    }
}
```