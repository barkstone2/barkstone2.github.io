---
created: 2024-10-30 08:54
updated: 2024-10-30 09:28
tags:
  - Algorithm
  - DP
  - 메모이제이션
  - 타뷸레이션
  - Memoization
  - Tabulation
  - 동적계획법
---
다이나믹 프로그래밍에서 값을 재활용하기 위해 메모이제이션과 타뷸레이션 기법을 사용할 수 있다.
둘은 비슷하지만 약간의 차이를 가지며, DP를 더 잘 사용하기 위해서 이 둘의 차이를 아는 것이 중요하다.
# 메모이제이션
메모이제이션은 일반적으로 재귀 함수에서 중복 부분 구조 문제를 해결하기 위해 사용된다.
예를 들어 아래 LCS 함수를 보자.
```java
int LCS(int i, int j) {
  if (i == 0 || j == 0) return 0;
  if (word1.charAt(i-1) == word2.charAt(j-1)) {
    return LCS(i-1, j-1) + 1;
  } else {
    return Math.max(LCS(i-1, j), LCS(i, j-1));
  }
}
```

이 함수에서는 특정 (i, j)에 대한 중복 호출이 발생할 수 있다. 이 중복 호출을 제거하기 위해 메모이제이션을 사용한다.
호출이 발생하고 재귀 함수가 값을 반환하기 전에 해당 호출에 대한 결과를 말 그대로 기록하는 것이 메모이제이션의 목적이다.
```java
int LCS(int i, int j) {
  if (i == 0 || j == 0) return 0;
  if (memo[i][j] != -1) return memo[i][j];
  if (word1.charAt(i-1) == word2.charAt(j-1)) {
    return memo[i][j] = LCS(i-1, j-1) + 1;
  } else {
    return memo[i][j] = Math.max(LCS(i-1, j), LCS(i, j-1));
  }
}
```

재귀 메서드가 호출됐을 때 메모이제이션된 값이 있다면 메서드를 수행하는 대신 기록된 값을 반환한다.
여기서 알 수 있듯이 메모이제이션은 실제 메서드가 호출된 시점, 다시 말해 값이 필요한 시점에 수행된다.
그리고 메서드가 한 번 호출되고 난 다음에는 메모이제이션 테이블의 값이 갱신된다.
다시 말해 코드를 아래처럼 변경해도 아무런 문제가 없다. 단, i나 j가 0인 경우는 배열의 값이 0으로 초기화 되어 있어야 한다.
```java
int LCS(int i, int j) {
  if (i == 0 || j == 0) return 0;
  if (memo[i][j] != -1) return memo[i][j];
  if (word1.charAt(i-1) == word2.charAt(j-1)) {
    LCS(i-1, j-1);
    return memo[i][j] = memo[i-1][j-1] + 1;
  } else {
    LCS(i-1, j);
    LCS(i, j-1);
    return memo[i][j] = Math.max(memo[i-1][j], memo[i][j-1]);
  }
}
```
# 타뷸레이션
타뷸레이션 역시 메모이제이션과 같이 값을 재활용하기 위한 기법임에는 동일하지만 한 가지 중요한 차이가 존재한다.

메모이제이션은 값이 필요한 시점, 다시 말해 메서드가 호출된 시점에 테이블의 값을 갱신하지만 타뷸레이션은 미래에 사용될 가능성이 있는 값을 미리 초기화한다.
```java
for (int i = 1; i <= word1.length(); i++) {  
    for (int j = 1; j <= word2.length(); j++) {  
        if (word1.charAt(i - 1) == word2.charAt(j - 1)) {  
            dp[i][j] = dp[i - 1][j - 1] + 1;  
        } else {  
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);  
        }  
    }  
}
```

현재 단계에서 초기화하는 `dp[i][j]`의 값은 현재 시점에 필요한 값은 아니다. 이후의 타뷸레이션 과정에서 해당 값이 사용될 수는 있지만, 이 역시 경우에 따라 확정적이지는 않다.
# 메모이제이션 -> 타뷸레이션
하향식에 메모이제이션이 적용된 코드를 타뷸레이션이 적용된 상향식으로 전환하기 위해서는 먼저 메모이제이션 코드를 자세히 살펴봐야 한다.
앞서 아래와 같이 메서드 호출을 별도로 분리하고 메모이제이션 테이블을 참조한 코드에 주목하자.
```java
LCS(i-1, j-1);
return memo[i][j] = memo[i-1][j-1] + 1;
```

여기서 `memo[i-1][j-1]`을 참조해 `memo[i][j]`를 갱신할 수 있는 이유는 테이블의 해당 값이 초기화되어 있다는 것을 알기 때문이다.
다시 말해 테이블의 값이 초기화되어 있다면, 테이블 값을 참조하는 방식으로 현재 값을 결정할 수 있다는 의미다.

재귀 메서드 안에서 현재 단계의 값인 `memo[i][j]`을 결정하기 위한 분기 조건이 두개이므로, 타뷸레이션에서도 동일한 조건에 따라 이전 테이블 값을 참조하도록 구성해야 한다.
```java
if (word1.charAt(i - 1) == word2.charAt(j - 1)) {  
    dp[i][j] = dp[i - 1][j - 1] + 1;  
} else {  
    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);  
}  
```

하지만 이것만으로는 아직 타뷸레이션을 사용할 수 없다.
먼저 기본 단계에 해당하는 값을 타뷸레이션 테이블에 초기화해주는 과정이 필요하다.

기본 단계를 결정하기 위해 메모이제이션 코드로 돌아가서 아래 코드에 주목하자.
```java
if (i == 0 || j == 0) return 0;
```
이 코드는 재귀 메서드의 기본 단계를 정의하고 있으며 이 기본 단계는 타뷸레이션에서도 동일하다.
따라서 타뷸레이션 테이블에서 i 혹은 j가 0인 경우의 값을 0으로 초기화해 줘야한다.
int 배열의 경우 기본 값이 0이기 때문에 별도의 초기화가 필요없지만, 기본 단계 값이 0이 아닌 경우에는 반드시 적절하게 테이블을 초기화해 줘야 한다.

앞서 말했듯이 타뷸레이션을 위해서는 반드시 참조할 테이블 값이 초기화되어 있어야 한다.
기본 단계는 타뷸레이션을 시작하기 위한 초기값을 지정하는 것이며, 기본 단계가 제대로 정의되지 않으면 타뷸레이션을 수행할 수 없다.