---
created: 2024-09-29 16:18
updated: 2024-09-30 18:10
tags:
  - Algorithm
---
> [!check] 관련 문제
> [수 찾기](https://www.acmicpc.net/problem/1920) - 기본적인 이분 탐색
> [K번째 수](https://www.acmicpc.net/problem/1300) - 정렬 대상과 탐색 조건에 대한 고민이 필요한 문제
> [가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015) - 정렬 대상에 대한 고민이 필요한 문제
# 이분 탐색의 정의
이분 탐색(이진 탐색)은 정렬된 데이터에서 특정한 값을 찾아내는 방법이다.
배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 혹은 오른쪽 부분 배열에 있는 지를 판단해 탐색 범위를 반으로 줄여나간다.

정렬된 데이터에서 수행되기 때문에 찾고자 하는 값이 속하지 않은 부분을 확실하게 버릴 수 있으며, 매 탐색마다 탐색 범위가 반으로 줄어들기 때문에 `O(logN)`의 시간 복잡도를 갖는다.

데이터의 삽입이나 삭제가 빈번할 때는 적합하지 않고 주로 고정된 데이터에 대한 탐색에 적합하다.
# 이분 탐색의 구현
먼저 코드부터 살펴보자.
```java
Arrays.sort(nums);
int binarySearch(int[] nums, int num) {  
    int start = 0;  
    int end = nums.length - 1;  
    while (start <= end) {  
        int mid = (start + end) / 2;  
        int target = nums[mid];  
        if (target == num) {  
            return mid;  
        } else if (target < num) {  
            start = mid + 1;  
        } else {  
            end = mid - 1;  
        }  
    }  
    return -1;  
}
```

코드에 대해 간단히 설명하자면 다음과 같다.
먼저 탐색할 배열의 첫 인덱스와 끝 인덱스를 각각 `start`와 `end`로 잡는다.
변수의 이름은 (left, right), (low, high)로 달라질 수 있다.

탐색은 start가 end보다 작거나 같은 동안 수행한다.
두 값을 더한 뒤 2로 나눈 mid 값을 설정하고, mid가 가리키는 값과 찾으려는 값을 비교해 탐색 범위를 조절한다.

위 코드에서는 단순히 값의 대소비교를 통해 탐색 범위를 줄였지만, 문제의 복잡도에 따라 더 복잡한 방법으로 탐색 범위를 결정해야 할 수도 있다.
우선 위 코드에서는 mid 값이 탐색할 값보다 작다면 현재 위치보다 오른쪽에 탐색할 값이 있음이 명확하다.

nums는 오름차순 정렬된 상태이므로 mid보다 왼쪽에 있는 값들은 탐색할 필요가 없다.
따라서 start를 mid + 1로 갱신해 mid + 1 ~ end 범위 안에서 다시 값을 탐색한다.

반대의 경우 현재 mid 값보다 작은 값만 탐색하면 되므로 end를 mid - 1로 갱신해 start ~ mid - 1 범위 안에서 다시 값을 탐색한다.

만약 mid 값과 현재 값이 같다면, 현재 값을 가리키는 인덱스를 반환할 수 있다.
탐색하려는 값이 배열 내에 존재하지 않을 수 있는데 여기서는 단순하게 -1을 반환하도록 했다.

자바의 내장 API인 `Arrays.binarySearch`와 `Collections.binarySearch`의 경우 값이 존재할 경우 해당 값의 인덱스를 반환하고, 값이 존재하지 않을 경우 `-(insert point - 1)`을 반환하게 된다.
JavaDoc에 따르면 `insert point`는 탐색한 값보다 큰 첫 번째 값의 인덱스를 가리킨다. 만약 배열의 모든 요소가 탐색한 값보다 작다면 배열의 길이가 `insert point`가 된다.

예를 들어 `[1, 2, 4]` 배열에 대해 `Arrays.binarySearch`를 수행한 결과는 다음과 같다.
```java
int[] nums = {1, 3, 6};
Arrays.binarySearch(nums, 0); // -1
Arrays.binarySearch(nums, 1); // 0
Arrays.binarySearch(nums, 2); // -2
Arrays.binarySearch(nums, 5); // -3
Arrays.binarySearch(nums, 10); // -4
Arrays.binarySearch(nums, 15); // -4
```
# 이분 탐색의 응용
쉬운 난이도의 이분 탐색 문제는 정렬된 데이터가 명확하고, 범위를 줄이기 위한 조건도 명확하다.
하지만 어려운 난이도의 문제는 정렬된 데이터가 드러나있지 않거나, 범위 축소 조건이 명확하게 드러나지 않는 경우가 많다고 느꼈다.

두 개의 문제를 예시로 이런 경우를 살펴보려고 한다.
다만 개인적인 경험에 의한 정리기 때문에 다르게 느낄 수 있다.
## 정렬된 데이터가 드러나있지 않은 경우
[BOJ 12015](https://www.acmicpc.net/problem/12015) 문제를 예시로 살펴보자.
이 문제는 고정된 수열 A에서 [[LIS(Longest Increasing Subsequence)]]를 도출하는 문제다.
수열 A 자체는 정렬되어 있지 않고, 정렬도 불가능하다.

LIS에 대해 모르는 상태로 처음 이 문제를 접했을 때는 이분 탐색을 떠올리는 것이 쉽지 않았다.
문제에서 드러나 있는 A라는 데이터가 정렬된 상태가 아니었기 때문이었다.

하지만 이 문제는 이분 탐색을 활용해야 하는 문제였고, 정렬된 데이터는 우리가 구할 LIS 그 자체가 된다.
LIS가 가장 긴 증가하는 부분 수열이고, 이는 다시 말해 LIS가 오름차순 정렬되어 있다는 것을 뜻한다.

즉, 아직 결정되지 않은 데이터인 LIS가 항상 정렬된 상태라는 것을 활용해 이분 탐색을 수행해야 하는 문제다.

이처럼 복잡한 형태의 문제는 먼저 정렬된 데이터 구조가 존재하는 지, 혹은 정렬된 데이터 구조를 생성하고 탐색할 수 있는 지를 먼저 파악해야 한다.
문제에서 명시적으로 정렬된 데이터 구조를 제공하지 않을 수 있음에 명심해야 한다.
## 범위 축소 조건이 드러나있지 않은 경우
이번에는 [BOJ 1300 - K번째 수](https://www.acmicpc.net/problem/1300) 문제를 살펴보자.

이 문제는 오름차순 정렬된 최대 길이 100억의 배열에서 k번째 값을 찾는 문제다.
배열 B가 정렬된 상태라는 정보가 주어졌지만 배열 B를 실제로 초기화하지 못하고(메모리 초과), 이분 탐색을 통해 탐색해야할 값이 드러나있지 않기 때문에 이분 탐색을 떠올리기가 쉽지 않았다.

B가 정렬된 상태라는 점에서 이분 탐색 사용을 고려할 수는 있었지만, 범위 축소 조건이 드러나 있지 않기 때문에 더 혼란스러웠다.

이 문제에서 범위 축소 조건을 알기 위해서는 문제에서 주어진 값 중 결정된 값이 k값이라는 점에서 시작해야 한다.
여기서 사고를 확장해 가며 정렬 상태의 데이터에서 인덱스가 가지는 의미와, 주어진 데이터의 특성을 고려해서 범위 축소 조건을 결정해야 한다.

이처럼 범위 축소 조건이 드러나있지 않은 문제에서는 문제에서 주어지는 값에서 사고를 확장해 나가는 작업이 필요하다.