---
created: 2024-09-06 21:37
updated: 2024-09-09 18:52
tags:
  - Algorithm
  - 알고리즘
  - 트리
  - 세그먼트_트리
---
# 세그먼트 트리가 필요한 이유
크기가 N인 배열에 대한 구간 쿼리를 처리하기 위해서는 최대 O(N)의 시간 복잡도가 필요하다.
이는 최대 N개의 요소를 살피며 최솟값, 최댓값, 구간합 등을 구하기 위해서다.

그렇다면 이런 쿼리가 M번 발생하고, M이 엄청나게 큰 수라고 가정해보자.
이때 필요한 시간 복잡도는 O(NM)이 되며 이는 엄청나게 비효율적이 될 수 있다.

N x N 매트릭스를 사용해서 문제를 해결하는 방법도 있지만 이 역시 완벽한 대안이 되지는 못한다.
N x N 매트릭스를 사용할 경우에는 O(1)의 시간으로 쿼리를 해결할 수 있지만, 매트릭스 구성에 O(N^2)의 시간 복잡도가 필요하며, 매트릭스 유지에 O(N^2)의 공간 복잡도가 필요하다.

반면 세그먼트 트리 사용 시 쿼리에 O(logN), 구성에 O(N)의 시간 복잡도로 문제를 해결할 수 있기에 이런 구간 문제를 해결하기 위해 세그먼트 트리가 사용된다.
# 세그먼트 트리란?
배열의 구간 쿼리 문제를 해결하기 위한 자료 구조로 배열이 트리의 리프 노드에 위치한다.
기본적으로 Full Binary Tree 형태를 가지는 이진 트리로, 배열의 길이가 2의 거듭 제곱인 경우에는 Perfect Binary Tree의 형태를 가진다.

리프 노드에는 배열의 값이 순서대로 할당되며, 리프 노드가 아닌 노드에는 세그먼트 구간에 대한 계산값이 저장된다.
주로 구간 최소값, 구간 최대값, 구간 합, 구간 곱, 구간 GCD 등을 구하는데 사용되며 이외에도 다양한 방법으로 사용될 수 있다.

구성, 업데이트, 쿼리 연산으로 구분된다.

>[!check] 세그먼트 트리 문제 풀어보기
> [BOJ - 2042 구간 합 구하기](https://www.acmicpc.net/problem/2042) - 구간 합 문제
> [BOJ - 11505 구간 곱 구하기](https://www.acmicpc.net/problem/11505) - 구간 곱 문제
> [BOJ - 2357 최솟값과 최댓값](https://www.acmicpc.net/problem/2357) - 최솟값, 최댓값 문제
> [BOJ - 2243 사탕상자](https://www.acmicpc.net/problem/2243) - 세트먼트의 노드 수를 활용한 문제
## 구성 연산
주어진 배열을 기반으로 세그먼트 트리를 구성하는 연산이다.
O(N)의 시간 복잡도를 가지며 주어진 배열을 반으로 나눠 왼쪽 세그먼트와 오른쪽 세그먼트에 대한 재귀 호출을 수행한다. N개의 요소를 모두 방문할 때까지 수행되기 때문에 O(N)의 시간 복잡도를 가진다.

세그먼트를 계속 반으로 나누기에 Full Binary Tree 형태를 가지며 최소 2N-1의 크기를 가진다.
일반적으로 4N의 크기를 설정해 트리의 크기 계산을 간소화하게 된다.
```java
int N = 5;
int[] nums = {0, 1, 3, 2, 5, 8};
int[] tree = new int[N*4];
buildTree(1, N, 1);

long buildTree(int start, int end, int node) {
    if (start == end) {
        return tree[node] = nums[start];
    }
    int mid = (start + end) / 2;
    return tree[node] = buildTree(start, mid,node*2) + buildTree(mid+1, end, node*2+1);
}
```
### 트리의 크기
길이가 N인 배열은 2N-1개의 노드를 사용한 세그먼트 트리로 표현할 수 있다. 이는 배열의 각 요소를 나타내는 N개의 리프 노드와 N-1개의 세그먼트 노드가 필요하기 때문이다.

> [!note] 세그먼트 노드가 N-1개인 이유
> N개의 노드 중 2개를 병합하는 과정을 하나의 노드만 남을 때까지 반복한다고 하자.
> 이때 각 병합 단계마다 남은 노드의 수가 1씩 줄어든다. 즉, N을 1로 만들려면 N-1번의 병합이 필요하다.
> 이는 세그먼트 트리의 구성 과정에서도 유사하게 적용된다. 아직 묶이지 않은 두 노드에 대해서 세그먼트 노드를 만들고, 이를 루트 노드가 생길 때까지 반복하게 된다.

다만 실제로 필요한 트리의 길이는 N의 값에 따라 달라질 수 있다.

이는 세그먼트 트리가 Complete Binary Tree가 아니라 Full Binary Tree의 형태를 가지기 때문이다.
N이 2의 거듭 제곱인 경우에는 Perfect Binary Tree이므로 트리의 크기를 2N-1로 설정할 수 있다.
하지만 N이 2의 거듭 제곱이 아닌 경우에는 아래와 같이 트리가 구성될 수 있다.
![[full-binary-tree.png]]

이 때 필요한 노드의 수는 2N-1개가 되지만, 배열을 통해 트리를 표현하기 위해서는 N보다 크거나 같으면서 가장 작은 2의 거듭 제곱인 X를 N 대신 사용해 필요한 트리의 크기를 계산해야 한다.
예를 들어 위의 경우 N의 값이 6이므로, X=8이 된다. 이에 따라 2X-1인 15가 트리의 크기가 된다.

다만 트리의 크기를 결정하기 위해 X를 계산하는 것이 번거로울 수 있기 때문에 아래의 과정을 거쳐 간소화된 값인 4N을 사용하는 것이 일반적이다.
- 만약 N이 `2^1024 + 1`이라면 트리의 크기는 `2^1025 * 2 - 1`이 된다.
- 이때 트리의 크기는 다음 식을 만족한다. `2^1025 * 2 - 1 < 2^1026`
- `2^1026`은 `4 * (2^1024 + 1) - 4`로 표현할 수 있고, 이는 `4N - 4`가 된다.
- 이를 이전 식에 대입하면 `tree size < 4N - 4`가 되므로 당연히 `tree size < 4N`이 성립한다.

만약 메모리 제약이 심한 경우라면 2X-1을 직접 계산해서 트리를 구성하면 된다.

> [!check] 트리 시작 인덱스에 따른 차이
> 트리가 1번 인덱스부터 시작하는 경우라면 트리의 크기를 2X-1이 아닌 2X로 설정해야 한다.
> 4N으로 설정하는 경우에는 추가 조치가 필요 없다.
## 쿼리 연산
쿼리 연산은 배열의 `[l, r]` 구간에 대한 쿼리를 질의하는 연산이다.
O(logN)의 시간 복잡도를 가지며 시간 복잡도에 대한 자세한 내용은 아래에 따로 정리했다.

세그먼트 트리에서 반환되는 값의 경우 세그먼트 트리의 용례에 따라 달라질 수 있으나 쿼리 연산의 기본 로직은 동일하다.
쿼리 범위인 `[l, r]`과 세그먼트의 범위인 `[s, e]`를 비교해 겹침 여부에 따라 다음의 동작을 수행한다.
1. 완전히 겹치는 경우 : `[l <= s && e <= r]`
	현재 세그먼트 범위가 모두 쿼리 범위에 포함되므로 세그먼트의 값 반환(최솟값, 최댓값, 구간합 등)
2. 일부 겹치는 경우 : `[l <= s <= r] || [l <= e <= r]`
	완전히 겹치는 세그먼트를 탐색하기 위해 세그먼트를 반으로 나눠 재귀 탐색
3. 겹치지 않는 경우
	현재 세그먼트 탐색을 중단하고 return

위 로직을 구현하기 위해서 기본적으로 start, end, left, right 변수가 필요하며, 트리를 가리키는 인덱스인 node도 함께 사용한다.
```java
long queryTree(int start, int end, int node, int left, int right) {
    if (left > end || right < start) {
        return 0;
    }

    if (left <= start && end <= right) {
        return tree[node];
    }

    int mid = (start + end) / 2;
    return queryTree(start, mid, node * 2, left, right) + queryTree(mid + 1, end, node * 2 + 1, left, right);
}
```
### 쿼리 연산 시간 복잡도
쿼리 연산의 시간 복잡도는 단순히 말하자면 O(logN)이며, 이는 트리의 높이를 의미한다. 트리의 높이가 logN인 이유는 세그먼트 트리 구성의 규칙성 때문이다.
최악의 경우에는 O(4logN)이며, 빅오 표현법에 따라 O(logN)으로 간소화 됐다는 언급을 찾아볼 수 있었다.

다만 왜 O(4logN)이 되는 지를 이해하기 위해서 여러 자료를 찾아봤는데, 명확하게 이해되는 설명이 없었고, 개인적으로 고민한 끝에 아래와 같은 방법을 통해 이해했다.

![[segment-tree-query-time-complexity.jpeg|500]]
위 이미지는 배열의 길이가 8인 트리에서 2~7 범위를 탐색했을 때의 방문 노드를 표시한 이미지다.
이와 같은 구조가 가장 많은 수의 노드를 방문하는 경우라고 판단했고, 이를 기준으로 시간 복잡도를 계산했다.

먼저 리프 노드까지 닿은 두 경로의 경우 항상 탐색 범위의 시작과 끝에만 위치할 수 있다. 이 경우에는 각 경로 탐색에 logN의 시간 복잡도가 필요하다. 정확히는 루트 노드를 공유하기 때문에 두 리프 노드 탐색에 2logN-1의 시간 복잡도가 필요하다.

리프 노드까지 탐색하지 않는 경우에는 다른 경로에서 갈라져 나온 것이기에 도달한 노드의 수만큼의 연산이 필요하다. 즉, 위의 이미지에서는 2번의 연산이 추가로 발생한다.
배열의 길이를 16, 32로 확장해보면 규칙성을 찾을 수 있는데, 리프 노드까지 탐색하지 않는 연산 수는 2(logN-2)번이 된다.

즉, 총 필요한 연산 수가 2logN + 2(logN - 2)가 되며, 이는 4logN - 4로 표현할 수 있다.
이를 빅오 표현법으로 나타내면 O(logN)이 된다.

>[!tldr] 배열의 길이가 2의 거듭 제곱이 아닌 경우
> 앞에서 시간 복잡도를 계산할 때는 편의를 위해서 배열의 길이를 2의 거듭 제곱으로 설정했다. 하지만 배열의 길이가 2의 거듭 제곱이 아니더라도 크게 다를 것은 없다.
> 배열의 길이가 2의 거듭 제곱이 되면 Perfect Binary Tree가 되며, 이보다 작으면 Full Binary Tree 형태를 가진다.
> 다시 말해 Perfect Binary Tree 일때 가장 많은 노드를 방문하는 것이 보장된다.
## 업데이트 연산
업데이트 연산은 배열의 값이 변경되는 경우에 필요한 연산이다.
세그먼트 트리의 값을 변경한 뒤에 다시 쿼리하는 등의 요구사항이 있는 경우에 구현할 수 있다.
구성 과정과 동일하게 재귀적으로 업데이트를 수행하며, 특정 값을 업데이트 하기 위해 O(logN)의 시간 복잡도가 필요하다.

실제 배열의 값을 업데이트하는 것과 동시에 세그먼트 트리의 세그먼트 노드에 기록된 값도 갱신해야 하므로 트리의 인덱스와 배열의 인덱스가 모두 필요하다.
배열을 가리키는 인덱스 idx가 `[s, e]` 범위를 벗어난 경우에는 return 하고, `[s, e]` 범위에 포함되는 경우에는 idx 구간을 포함하는 세그먼트 노드이므로 현재 트리 값을 갱신한다.
start와 end가 동일한 위치, 즉 리프 노드에 도달한 경우에는 더 이상 재귀 호출이 필요 없으므로 마찬가지로 return한다.
```java
void updateTree(int start, int end, int node, int idx, long dif) {
    if (idx < start || idx > end) {
        return;
    }

    tree[node] += dif;
    if (start == end) {
        return;
    }

    int mid = (start + end) / 2;
    updateTree(start, mid, node * 2, idx, dif);
    updateTree(mid + 1, end, node * 2 + 1, idx, dif);
}
```