---
created: 2024-07-27 11:07
updated: 2024-09-23 12:40
tags:
  - 리액트
  - React
  - JS
---
# 정의 및 사용법
- 컴포넌트에서 사이드 이펙트를 수행하기 위해 사용하는 훅
- useState로 선언된 상태 변경 시 렌더링이 수행되므로, 렌더링 이외의 작업, 말 그대로 사이드 이펙트를 처리하기 위해 사용하는 훅이다.
- 데이터 가져오기, 수동으로 DOM 업데이트, 타이머 설정 등의 작업을 수행한다.
- useEffect가 클래스형 컴포넌트에서 componentDidMount, componentDidUpdate, componentWillUnmount와 같은 생명주기 메서드를 대체한다.
- useEffect 내부에서 사용하는 모든 함수와 변수는 의존성 배열에 추가해야 한다. 여기서 사용은 값을 참조하는 것을 의미하며, 값을 변경하기만 하는 경우에는 의존성 배열에 추가하지 않아도 된다.
- 함수의 경우 useCallback 훅을 사용하여 함수를 메모이제이션 해야 한다.

기본적인 사용법은 다음과 같다.
```jsx
function MyComponent() {
	useEffect(() => {
		// 여기에 사이드 이펙트를 수행하는 코드를 작성
		return () => {
			// 정리(cleanup) 작업을 여기에 작성
		};
	}. [/* 의존성 배열 */]);
	return (
		<div>
			{/* 컴포넌트 렌더링 내용 */}
		</div>
	)
}
```
# 함수 구조
- useEffect는 첫 번째 인자로 함수를 받고, 두 번째 인자로 의존성 배열을 받는다.
# 의존성 배열
- 의존성 배열은 이펙트가 실행될 조건을 지정한다.
- 의존성 배열에 특정 상태나 프롭을 포함하면, 해당 값이 변경될 때마다 이펙트가 다시 실행된다.
- 의존성 배열을 생략한 경우 컴포넌트가 렌더링될 때마다 이펙트가 실행되며, 이는 의도하지 않은 성능 문제를 야기할 수 있으므로 주의가 필요하다.
- 의존성 배열에 빈 배열을 넘기면 컴포넌트가 최초로 렌더링 될때 한번만 이펙트가 실행된다.
- 의존성 배열에 여러 상태 값을 넘길 경우, 상태 중 하나라도 변경되면 이펙트 함수가 수행된다.
- 의존성 배열에 넘기는 상태는 useState나 useProps로 선언된 값일 필요는 없다. 컴포넌트 내에서 선언된 변수 또는 상수를 넘길 수도 있다.
```jsx
useEffect(() => {
	console.log('count 값이 변경되었습니다.');
}, [count]);
```
# 정리(cleanup) 함수
이펙트 함수 내에서 반환하는 함수는 컴포넌트가 언마운트될 때 또는 이펙트가 다시 실행되기 전에 호출된다.
주로 타이머를 정리하거나 이벤트 리스너를 제거하는데 사용된다.
```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log('타이머 실행 중...');
  }, 1000);

  return () => {
    clearInterval(timer);
    console.log('타이머가 정리되었습니다.');
  };
}, []);
```
# 테스트 코드 작성
여기서는 Vitest를 사용한 테스트 방법을 다루겠다.
