---
created: 2024-09-12 10:04
updated: 2024-09-12 10:39
tags:
  - Java/DataStructure
---
# `ArrayDeque` 정의
크기 변경이 가능한 배열을 사용한 `Deque` 구현체로 스택과 큐의 기능을 모두 제공한다.
`ArrayList`와 달리 `null`을 허용하지 않는다.
## 원형 버퍼 구조
내부에서 배열을 사용하지만 원형 버퍼 구조를 사용하기 때문에 앞과 뒤에 모두 삽입, 삭제 연산을 효율적으로 할 수 있다.

원형 버퍼 구조는 배열의 첫 요소와 끝 요소를 가리키는 포인터를 두고, 배열의 시작과 끝을 서로 연결하는 구조를 말한다.
예를 들어 0번 인덱스에 삽입하고 쉬프트 연산을 하는 대신 배열의 뒷 부분에 삽입하고 head 포인터만 이동시키는 형태인 셈이다.

포인터를 이동한 인덱스는 아래와 같이 모듈러 연산을 통해 계산한다.
```java
es[head = dec(head, es.length)] = e;
static final int dec(int i, int modulus) {  
    if (--i < 0) i = modulus - 1;  
    return i;  
}
```

이런 계산에 사용되는 메서드들은 공통으로 사용되고, 인스턴스 변수에 접근하지 않기 때문에 효율성을 위해 정적 메서드로 선언되어 있다.
## 성능
Javadoc에 따르면 스택으로 사용 시 `Stack`보다 빠를 가능성이 높으며, 큐로 사용할 때는 `LinkedList`보다 빠를 가능성이 높다.

`ArrayDeque`가 `Stack`보다 빠른 이유는 `Stack`이 `Vector`를 사용하고, `Vector`가 동기화를 지원하기 때문이다. 두 구현체의 동기화 유무로 인해 속도 차이가 발생한다.

반면 큐로 사용할 때는 경우에 따라 `ArrayDeque` 사용이 더 비효율적일 수도 있다.
일반적인 경우에는 연속된 메모리 공간을 사용하는 `ArrayDeque`가 메모리 접근 측면이나 캐싱 측면에서 `LinkedList`보다 더 효율적이다.

다만 배열을 기반으로 하기 때문에 내부 배열 크기를 늘리는 작업에서 오버헤드가 발생하고, 이 때문에 큐의 크기가 크거나 변동이 심한 경우에는 `LinkedList` 사용이 더 효율적일 수 있다.