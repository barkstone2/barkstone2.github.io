---
created: 2024-08-22 22:59
updated: 2024-08-26 00:05
tags:
  - MySQL
  - Database
  - DB
  - SQL
references:
  - Real MySQL 8.0
---
# 실행 계획 확인
MySQL에서 실행 계획을 확인하려면 `EXPLAIN` 명령을 사용하면 된다.
```sql
EXPLAIN 
/* 실제 쿼리 */
```

`EXPLAIN` 명령은 MySQL 3.23.11 버전부터 지원되는 기능이므로, 거의 대부분의 환경에서 사용할 수 있다.
MySQL 8.0부터는 `FORMAT` 옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택할 수 있다.
```sql
EXPLAIN FORMAT=TREE
...

EXPLAIN FORMAT=JSON
...
```
# 쿼리의 실행 시간 확인
MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다.
`EXPLAIN ANALYZE` 명령은 항상 결과를 TREE 포맷으로 보여주기 때문에 `EXPLAIN` 명령에 `FORMAT` 옵션을 사용할 수 없다.
```sql
EXPLAIN ANALYZE
/* 실제 쿼리 */
```
## 출력 예시
`EXPLAIN ANALYZE` 명령을 사용하면 아래와 같이 TREE 형태의 포맷으로 결과가 출력된다.
``` text
A) -> Table scan on <temporary>  (actual time=12.8..12.8 rows=228 loops=1)
B)    -> Aggregate using temporary table  
			(actual time=12.8..12.8 rows=228 loops=1)
C)       -> Nested loop inner join  (cost=364 rows=2207) 
				(actual time=2.14..11.1 rows=2221 loops=1)
D)          -> Index lookup on e using idx_firstname (first_name='Matt')  
					(cost=81.5 rows=233) 
					(actual time=2.09..4.63 rows=233 loops=1)
E)          -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  
					(cost=0.269 rows=9.47) 
					(actual time=0.0229..0.0265 rows=9.53 loops=233)
```
## 읽는 순서
TREE 포맷에서 들여쓰기는 호출 순서를 의미하며, 실제 실행 순서는 다음 기준으로 읽으면 된다.
- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행

따라서 위 쿼리의 실행 계획은 다음의 실행 순서를 의미한다.
```text
1. D) Index lookup on e using idx_firstname
2. E) Index lookup on s using PRIMARY
3. C) Nested loop inner join
4. B) Aggregate using temporary table
5. A) Table scan on <temporary>
```
## 해석
`EXPLAIN ANALYZE` 명령은 실제 소요된 시간(actual time)과 처리한 레코드 건수(rows), 반복 횟수(loops)를 출력한다.

E) 라인에 나열된 값들을 살펴보면 다음과 같은 의미를 지닌다.
- `actual time=0.0229..0.0265` : `employees` 테이블에서 읽은 `emp_no` 값을 기준으로 `salaries` 테이블에서 일치하는 레코드를 검색하는데 걸린 시간(밀리초)을 의미한다. 첫 번째 숫자 값은 첫 번째 레코드를 가져오는 데 걸린 평균 시간(밀리초)을 의미하며, 두 번째 숫자 값은 마지막 레코드를 가져오는 데 걸린 평균 시간(밀리초)을 의미한다.
- `rows=9.53` : 테이블에서 읽은 `emp_no`에 일치하는 `salaries` 테이블의 평균 레코드 건수를 의미한다.
- `loops=233` : `employees` 테이블에서 읽은 `emp_no`를 이용해 `salaries` 테이블의 레코드를 찾는 작업이 반복된 횟수를 의미한다. 즉, `employees` 테이블에서 읽은 `emp_no`의 개수가 233개임을 의미한다.

> [!info] actual time 필드와 rows 필드가 평균 값을 나타내는 이유
> 두 필드가 평균 값을 나타내는 이유는 loops가 1보다 크기 때문이다.
> 즉, `salaries` 테이블에서 `emp_no` 일치 건을 찾는 작업을 233번 반복해서 실행했는데, 매번 `salaries` 테이블에서 첫 번째 레코드를 읽는 데 평균 0.0229밀리초가 걸렸으며, 마지막 레코드를 읽는 데 평균 0.0265밀리초가 걸린 것을 의미한다.
> 또한 평균 9.53개의 레코드를 가져오므로 9.53개의 레코드르 모두 읽는데 0.0265밀리초가 걸린 것이다.

>[!warning] 주의
> `EXPLAIN ANALYZE` 명령은 `EXPLAIN` 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여준다.
> 쿼리의 실행 시간이 아주 많이 걸리는 쿼리라면 `EXPLAIN ANALYZE` 명령을 사용했을 때, 쿼리가 완료돼야 실행 계획의 결과를 확인할 수 있다.
> 쿼리의 실행 계획이 아주 나쁜 경우라면 `EXPLAIN` 명령으로 먼저 실행 계획만 확인해서 어느 정도 튜닝한 후 `EXPLAIN ANALYZE` 명령을 실행하는 것이 좋다.
# 실행 계획 분석
실행 계획 분석에서 가장 중요한 것은 실행 계획에서 아래와 같은 내용들을 이해하는 것이다.
- 실행 계획이 어떤 접근 방법을 사용하는지
- 실행 계획이 어떤 최적화를 수행하는지
- 실행 계획이 어떤 인덱스를 사용하는지

테이블 포맷을 기준으로 `EXPLAIN` 명령을 실행하면 쿼리 문장에서 사용된 테이블의 개수만큼 레코드가 출력된다. 이때 서브쿼리로 생성된 임시 테이블이 있다면 임시 테이블도 레코드로 출력된다.
실행 순서는 위에서 아래로 순서대로 표시되지만 UNION이나 상관 서브쿼리와 같은 경우 순서대로 표시되지 않을 수도 있다.

출력된 실행 계획에서 위쪽에 출력된 결과일수록(id 칼럼의 값이 작을수록) 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블을 나타낸다.
## 출력 예시
```sql
EXPLAIN
SELECT *
FROM employees e
INNER JOIN salaries s ON s.emp_no = e.emp_no
WHERE e.first_name = 'Matt';
```

위 명령을 실행하면 아래와 같은 결과가 출력된다.
![[explain.png]]

각 칼럼의 의미하는 바를 하나씩 살펴보자.
## id 칼럼
id 칼럼은 각 SELECT 쿼리를 구분하는 용도로 사용된다.
조인을 사용하는 경우에는 실행 계획 레코드가 여러개로 표시되지만 id가 증가하지는 않는다.
서브 쿼리로 또 다른 SELECT 쿼리를 사용한 경우에 id가 증가한다.
id의 순서는 테이블의 접근 순서를 의미하지는 않는다.
## select_type 칼럼
각 SELECT 쿼리가 어떤 타입의 쿼리인지 표시하는 값이다. 각 레코드 별로 할당되는 것이 아니라 각 SELECT 쿼리, 다시 말해 id를 기준으로 할당된다.
다양한 타입이 사용될 수 있지만 여기에는 주로 사용되는 몇 가지 타입에 대해서만 정리하겠다.
### SIMPLE
UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우에 사용된다. 쿼리에 조인이 포함된 경우도 마찬가지다.
쿼리 문장이 아무리 복잡해도 실행 계획에서 SIMPLE 타입인 SELECT 쿼리는 하나만 존재한다.
일반적으로 제일 바깥 SELECT 쿼리의 타입이 SIMPLE로 표시된다.
### PRIMARY
UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 SELECT 쿼리인 경우에 사용된다.
SIMPLE과 마찬가지로 PRIMARY 타입의 쿼리는 오직 하나만 존재할 수 있다.
### UNION
UNION으로 결합되는 SELECT 쿼리 중 첫 번째 SELECT 쿼리를 제외한 나머지는 UNION 타입이 된다.
```sql
EXPLAIN
(SELECT emp_no FROM employees e1 LIMIT 10) UNION ALL
(SELECT emp_no FROM employees e2 LIMIT 10) UNION ALL
(SELECT emp_no FROM employees e3 LIMIT 10);
```

예를 들어 위 실행 계획 실행 시 아래와 같은 결과가 도출된다.
```text
+----+-------------+-------+
| id | select_type | table |
+----+-------------+-------+
|  1 | PRIMARY     | e1    |
|  2 | UNION       | e2    |
|  3 | UNION       | e3    |
+----+-------------+-------+
```
### SUBQUERY
select_type에서 SUBQUERY는 FROM 절 이외에서 사용된 서브쿼리를 나타낸다.
### DERIVED
SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. 이때 생성되는 테이블을 파생 테이블이라고도 한다.
주로 FROM 절에 사용된 서브쿼리가 해당 타입을 가지게 된다.
MySQL 8.0 이상을 사용한다면 옵티마이저가 불필요한 서브쿼리를 조인으로 재작성해서 처리한다.
다만, 옵티마이저에 한계가 있으므로 불필요한 서브쿼리를 작성하지 않도록 주의가 필요하다.
### MATERIALIZE
MySQL 5.6버전부터 도입된 타입으로 주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.
### 나머지
이외에도 아래와 같은 타입들이 더 존재한다.
- DEPENDENT UNION : UNION 쿼리가 외부 쿼리의 값을 참조하는 경우
- UNION RESULT : UNION 결과를 담아두는 임시 테이블을 나타낸다.
- DEPENDENT SUBQUERY : 서브쿼리가 외부 쿼리의 값을 참조하는 경우
- DEPENDENT DERIVED : 파생 테이블이 다른 테이블의 값을 참조하는 경우
- UNCACHEABLE SUBQUERY : 캐싱이 불가능한 SUBQUERY 타입
- UNCACHEABLE UNION : 캐싱이 불가능한 UNION 타입
## table 칼럼
MySQL 서버의 실행 계획은 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다.
```text
+----+-------------+-----------+
| id | select_type | table     |
+----+-------------+-----------+
|  1 | PRIMARY     | employees |
+----+-------------+-----------+
```

 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.
```text
+----+-------------+-------+
| id | select_type | table |
+----+-------------+-------+
|  1 | PRIMARY     | e     |
+----+-------------+-------+
```

table 칼럼에 `<derived N>`과 같이 `<>`로 둘러싸인 이름이 명시되는 경우는 임시 테이블을 의미한다.
이를 쿼리의 실행 순서를 파악하는데 사용할 수 있다.
예를 들어 아래의 실행 계획에서 2번 쿼리가 먼저 실행되고, 이를 통해 `<derived2>`가 생성됨을 알 수 있다.
```text
+----+-------------+------------+
| id | select_type | table      |
+----+-------------+------------+
|  1 | PRIMARY     | <derived2> |
|  1 | PRIMARY     | e          |
|  2 | DERIVED     | de         |
+----+-------------+------------+
```
## partitions 칼럼
MySQL 5.7 버전까지는 `EXPLAIN PARTITION` 명령어를 사용해야 옵티마이저가 사용하는 파티션 목록을 확인할 수 있다.
MySQL 8.0 버전부터는 `EXPLAIN` 명령어만으로 파티션 관련 실행 계획까지 모두 확인할 수 있다.
SELECT 쿼리로 조회한 데이터가 어떤 파티션에 저장되어 있는지를 나타낸다.
## type 칼럼
MySQL 서버가 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.
일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인해야 하므로 type 칼럼은 반드시 체크해야 한다.

하나의 SELECT 쿼리에는 오직 하나의 type만 사용될 수 있으며, ALL 타입을 제외한 모든 타입은 인덱스를 사용하는 접근 방법이다.
또한 index_merge를 제외한 방법에서는 하나의 인덱스만을 사용한다.
이제 각 접근 방법을 성능이 빠른 순서대로 하나씩 살펴보자.
### system
레코드가 한 건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
InnoDB 스토리이 엔진에서는 나타나지 않고 MyISAM이나 MEMORY 테이블에서만 사용된다.
### const
프라이머리 키나 유니크 키 칼럼을 WHERE 조건절에 사용하고, 반드시 1건을 반환하는 쿼리의 처리 방식이다.
다른 DBMS에서는 유니크 인덱스 스캔이라고도 표현한다.
복합키의 일부 칼럼만 조건으로 사용하는 경우에는 const 타입의 접근 방법을 사용할 수 없다.
키의 일부만 조건으로 사용하는 경우에는 ref로 표시된다.

> [!info] 상수화
> const 타입의 쿼리는 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화한다.
> ```sql
> EXPLAIN
> SELECT COUNT(*)
> FROM employees e1
> WHERE first_name=(SELECT first_name FROM employees e2 WHERE emp_no = 100001);
> ```
> 
> 예를 들어 위 쿼리는 아래와 같이 최적화 된다.
> ```sql
> EXPLAIN
> SELECT COUNT(*)
> FROM employees e1
> WHERE first_name='Jasminko'; # emp_no가 100001인 사원의 first_name 값
> ```
### eq_ref
여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
조인에서 처음 읽은 테이블의 칼럼값을 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용하는 경우를 의미한다.
마찬가지로 복합키의 일부만을 사용하는 경우 이 접근 방식을 사용할 수 없다.
### ref
eq_ref와는 달리 조인의 순서와 관계없이 사용된다.
프라이머리 키나 유니크 키가 아닌 일반 인덱스에도 사용되는 접근 방식이다.
인덱스의 종류와 관계없이 동등(equal) 조건으로 검색할 때 ref 접근 방법이 사용된다.
반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않다.
하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다.
> [!tip] const & eq_ref & ref
> - const : 조인의 순서와 관계없이 PK나 유니크 키의 모든 칼럼에 대해 동등(Equal) 조건으로 검색(반드시 1건의 레코드만 반환)
> - eq_ref : 조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번째 테이블을 PK나 유니크 키로 동등 조건 검색(두 번째 테이블은 반드시 1건의 레코드만 반환)
> - ref : 조인의 순서와 인덱스의 종류에 관계없이 동등 조건으로 검색(1건의 레코드 반환이 보장되지 않음)
> 
> 세 접근 방법 모두 WHERE 조건절에 동등 비교 연산자를 사용한다는 공통점이 있다.
> 동등 비교 연산자는 `=` 또는 `<=>`을 의미하며 `<=>`는 NULL에 대한 비교 방식만 다르다.(NULL 끼리의 동등 비교에 true 반환)
### ref_or_null
ref 접근 방법과 동일한데 NULL 비교가 추가된 형태다. 이름 그대로 ref 방식 또는 NULL 비교(IS NULL) 접근 방법을 의미한다.
실제로 많이 활용되지 않지만, 사용된다면 나쁘지 않은 접근 방법이라고 기억해두면 충분하다.
### unique_subquery
WHERE 조건절에서 IN(subquery) 형태의 쿼리를 사용할 때의 접근 방법이다. 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

> [!tip] MySQL 8.0의 최적화
> MySQL 8.0 버전에서는 WHERE 조건절에 사용된 `IN(subquery)` 형태의 세미 조인을 최적화하는 많은 기능이 도입됐기 때문에 더 최적화된 다른 접근 방법이 표시될 수 있다.
### index_subquery
IN(subquery)에서 subquery가 중복된 값을 반환할 수도 있다. 이때 서브쿼리 결과의 중복된 값을 인덱스를 이용해 제거할 수 있는 경우에 사용되는 접근 방법이다.
### range
인덱스 레인지 스캔 형태의 접근 방법이다. 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미한다.
주로 `<`, `>`, `IS NULL`, `BETWEEN`, `IN`, `LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.
일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법이지만 MySQL 서버가 가진 접근 방법 중에서 상당히 우선순위가 낮다.
얼마나 많은 레코드를 필요로 하느냐에 따라 다르지만, range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.

> [!info] 인덱스 레인지 스캔
> 일반적으로 인덱스 레인지 스캔은 const, ref, range 세 가지 접근 방법을 모두 묶어서 지칭하는 것이다.
### index_merge
지금까지의 접근 방법과 달리 2개 이상의 인덱스를 사용하는 접근 방법이다.
각 인덱스를 사용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다.

여러 인덱스를 읽어야하므로 일반적으로 range 접근 방법보다 효율성이 떨어지며 전문 검색 인덱스 사용 시에는 index_merge가 적용되지 않는다.
index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 교집합, 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

MySQL 매뉴얼에서는 index_merge가 ref_or_null 바로 다음 우선순위를 가지지만, 위와 같은 이유 때문에 range 접근 방법보다 느려질 수 있다.
여러 알고리즘을 통해 실행될 수 있으며 사용된 알고리즘은 Extra 칼럼에 표시된다. 이때 사용된 알고리즘에 따라 효율성이 달라질 수 있다.
자세한 내용은 extra 칼럼에 대한 부분에서 다룰 예정이다.
### index
인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다.
풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같지만 일반적으로 데이터 파일 전체보다 인덱스의 크기가 작으므로 인덱스 풀 스캔 시 풀 테이블 스캔보다 빠르다.
또한 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 훨씬 효율적이라 할 수 있다.

index 방식이 적용되기 위해서는 다음 조건 중 2개 이상을 충족해야 한다.
- range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우(필수 조건)
- 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우(데이터 파일을 읽지 안아도 되는 경우)
- 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우(별도의 정렬 작업을 피할 수 있는 경우)
### ALL
풀 테이블 스캔을 의미하는 접근 방법이다.
### fulltext
MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 방법을 의미한다.
전문 검색은 `MATCH(...) AGAINST(...)` 구문을 사용해서 실행하며 전문 검색용 인덱스가 반드시 존재해야 한다.
아직 전문 검색을 수행할 일이 없고, 당장 정리하기에는 알아야할 내용이 많으므로 이 부분은 나중에 따로 정리하도록 하겠다.
MySQL 서버에서의 우선순위는 ref 다음에 위치하고 있다.
### 튜닝 필요 여부
ref 타입까지는 인덱스의 분포도가 나쁘지 않다면 성능상의 문제를 일으키지 않는다.
따라서 const, eq_ref, ref 방식일 경우에는 쿼리 튜닝을 하지 않고 넘어가도 무방하다.
index, ALL 방식의 경우 튜닝이 반드시 필요하며, 나머지의 경우에는 튜닝 필요 여부에 대한 확인이 필요하다.
## possible_keys 칼럼
옵티마이저가 쿼리를 처리하기 위해 후보로 선정했던 접근 방법에서 사용된 인덱스를 의미한다.
실제로 사용된 인덱스를 의미하는 것이 아니며 특별한 경우를 제외하고는 그냥 무시해도 된다.
## key 칼럼
최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.
쿼리를 튜닝할 때는 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.

key 칼럼에 PRIMARY가 표시되면 PK를 사용한다는 의미이고, 이외에는 인덱스를 생성할 때 부여했던 고유한 이름을 나타낸다.

type 칼럼 값이 index_merge인 경우에는 key 칼럼에 여러 인덱스가 표시될 수 있으며, 이외의 경우에는 반드시 하나의 인덱스만 사용된다.
## key_len 칼럼
검색에 사용된 키의 길이를 의미한다. 생각보다 중요한 정보로, 이를 통해 복합 인덱스의 몇 번째 칼럼까지 사용됐는지를 알 수 있다.
에를 들어 (dept_no, emp_no)으로 구성된 PK를 가지는 테이블에서 dept_no만을 사용해 조회할 경우 다음과 같은 실행 계획을 가진다.
```text
+----+-------------+----------+------+---------+---------+
| id | select_type | table    | type | key     | key_len |
+----+-------------+----------+------+---------+---------+
|  1 | PRIMARY     | dept_emp | ref  | PRIMARY | 16      |
+----+-------------+----------+------+---------+---------+
```

이는 dept_no 칼럼의 타입이 CHAR(4)이고, utf8mb4 문자 집합을 사용하기 때문에 PK에서 앞쪽 16바이트만 유효하게 사용했음을 나타낸다.
반면 (dept_no, emp_no) 칼럼을 모두 조건에 사용할 경우 key_len이 20이 된다.

> [!caution] varchar와 keylen
> 키를 구성하는 컬럼을 varchar 타입으로 사용하는 경우에 주의해야할 점이 있다.
> 고정된 크기를 가지는 char, int 등과 달리 varchar 타입은 실제로 저장된 데이터에 따라 길이가 가변적으로 변한다.
> 만약 칼럼의 타입이 varchar(100)고, 실제 데이터는 10~20 길이로만 구성된 경우에 PK를 통해 조회할 경우의 key_len은 실제 데이터의 길이가 아닌 칼럼에 정의된 길이인 100 * 4(char set에 따라 다르다)가 된다.
## ref 칼럼
접근 방법이 ref인 경우에 참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여준다.
상수값을 지정했다면 ref 칼럼의 값이 const로 표시되고, 다른 테이블의 칼럼값이면 해당 테이블명과 칼럼명이 표시된다.
이 칼럼에 표시되는 값은 일반적으로 크게 신경쓰지 않아도 무방하다.

다만, func로 표시되는 경우에는 참조값을 그대로 사용하지 않고 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조했다는 것을 의미한다.
사용자가 명시적으로 값을 변환한 경우 이외에 MySQL 서버 내부적으로 값을 변환하는 경우에도 func가 사용될 수 있으며, 이런 문제를 방지하기 위해 조인 칼럼의 타입을 일치시키는 것이 좋다.
## rows 칼럼
실행 계획의 효율성을 판단하기 위해 예측했던 레코드 건수를 의미한다.
옵티마이저가 산출해 낸 예상값이라서 정확하지는 않으며, 반환하는 레코드의 수가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미한다.
이때 산출된 예측값은 인덱스를 사용하는 조건에 일치하는 레코드 수를 의미한다.
## filtered 칼럼
조건절에 사용되는 모든 조건이 항상 인덱스를 사용할 수 있는 것은 아니다.
filtered 칼럼은 인덱스를 사용할 수 없는 조건으로 필터링되고 남은 비율을 의미한다.

예를 들어 이름이 Matt인 사원을 찾을 때는 인덱스를 통해 찾을 수 있지만, 이중 고용일이 특정 기간에 포함되는 사원을 찾을 때는 인덱스를 사용할 수 없다.
이때 rows 칼럼의 값이 100이고 filtered 칼럼의 값이 10%라면, 이름이 Matt인 사원이 100명이고, 이중 10%인 10명만이 고용일 조건에 부합한다는 것을 의미한다.

만약 조인을 수행하고 있다면, 이렇게 필터링되고 남은 10건의 레코드에 대해서 조인이 발생한다.
따라서 filtered 칼럼의 값이 얼마나 정확하게 예측되냐에 따라 조인의 성능이 달라질 수 있다.

또한 필터링 조건을 적절하게 사용해 조인 횟수를 줄이는 것도 성능 향상에 도움이 된다.
## [[Extra 칼럼]]
실행 계획에서 성능에 관련된 중요한 내용이 자주 표시된다. 주로 내부적인 처리 알고리즘에 대해 조금 더 깊이 있는 내용을 보여주는 경우가 많으며 일반적으로 2~3개씩 함께 표시된다. MySQL 서버의 버전이 업그레이드되고 최적화 기능이 도입될수록 새로운 내용이 더 추가될 수 있다.

전체 내용을 다루기에는 너무 방대하기 때문에 여기서는 중요한 몇 가지 내용들에 대해서만 정리하려고 한다. 나머지 내용들은 필요할 때 MySQL의 매뉴얼을 찾아보며 하나씩 추가로 정리하도록 하겠다.
### Using where
MySQL 엔진 레이어에서 별도의 필터링 작업을 처리한 경우에 표시된다.
스토리지 엔진에서 100건의 데이터를 읽었지만 MySQL 엔진에서 처리 후 10건만 반환하는 경우 등에 해당한다.
불필요하게 많은 데이터를 스토리지 엔진으로부터 읽고 있을 수 있으므로 경우에 따라 성능상의 문제를 일으킬 지 점검해야 한다.
### Using filesort
ORDER BY를 처리하는데 인덱스가 사용되지 못했음을 의미한다.
ORDER BY가 사용된 쿼리의 실행 계획에서만 나타난다.
조회된 레코드를 정렬용 메모리 버퍼에 복사해 퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행함을 의미한다.
이 문구가 출력된다면 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.
### Using temporary
MySQL 서버에서 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용한 경우에 표시된다.
임시 테이블은 메모리 상에 생성될 수도 있고 디스크 상에 생성될 수도 있다. 실행 계획 상으로는 임시 테이블이 어디에 생성됐는지 확인할 수 없다.

> [!caution] 주의
> 해당 메시지가 표시되지 않은 경우에도 임시 테이블을 사용하는 경우가 있으니 주의해야 한다.
> 대표적으로 아래와 같은 경우에 임시 테이블이 사용된다.
> - `FROM` 절에 서브쿼리 사용(Derived table로 표시되지만 임시 테이블이다.)
> - `COUNT(DISTINCT column1)`를 포함하는 쿼리에 인덱스를 사용할 수 없는 경우
> - `UNION`이나 `UNION DISTINCT`이 사용된 경우
> - 인덱스를 사용하지 못하는 정렬 작업(임시 버퍼 공간으로 부족한 경우)
### Using index
데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 표시된다.
다시 말해 커버링 인덱스가 사용되는 경우를 의미하며, 인덱스 레인지 스캔의 성능이 만족스럽지 못한 경우에 커버링 인덱스를 사용하도록 튜닝하면 큰 성능 향상을 볼 수 있다.

인덱스를 검색해서 일치하는 키 값들을 찾아낸 후, 해당 키들로 데이터 파일을 다시 검색해야 하고, 일반적으로 이 과정에서 비용이 많이 발생한다.
커버링 인덱스를 사용할 경우에는 이런 작업 없이 인덱스에서 필요한 데이터를 모두 읽으므로 훨씬 효율적이다.

InnoDB의 모든 테이블이 클러스터링 인덱스로 구성되기 때문에 세컨더리 인덱스에 PK가 포함되어 있지 않더라도 PK에 대해 커버링 인덱스가 사용될 수 있다.

인덱스를 사용하는 모든 접근 방식에서는 Using index가 표시될 수 있는데, 이때는 커버링 인덱스가 사용되지 않을 때보다 더 효율적이다.
풀 인덱스 스캔이 발생하는 경우에도 커버링 인덱스를 사용하는 것이 훨씬 효율적이다.
### Using index condition
MySQL 옵티마이저가 [[인덱스 컨디션 푸시 다운]] 최적화를 사용한 경우에 표시된다.
### Using MRR
[[MRR|Multi Range Read]] 최적화가 사용된 경우에 표시된다.
### Using index for skip scan
옵티마이저가 [[인덱스 스킵 스캔]] 최적화를 사용한 경우에 표시된다.
### Not exists
`NOT IN(subquery)`이나 `NOT EXISTS` 형태의 안티-조인을 사용하는 대신 아래와 같이 아우터 조인(LEFT OUTER JOIN)을 사용해서 안티-조인을 구현할 수 있다.
```sql
SELECT *
FROM dept_emp de
	LEFT JOIN deprartments d ON de.dept_no = d.dept_no
WHERE d.dept_no IS NULL;
```

이때 Extra 칼럼에 Not exists가 표시되며 이는 옵티마이저가 레코드의 존재 여부만을 검사했다는 것을 의미한다.
만약 조건에 일치하는 레코드가 여러 건이 있더라도, 딱 1건만 조회해보고 결과를 반환하는 최적화를 의미한다.